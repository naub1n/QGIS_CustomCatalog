# -*- coding: utf-8 -*-
"""
/****************************************************************************
 CustomCatalogAddConnexionDialog
                                 A QGIS plugin
 Create your own catalog based on various sources and versions
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-11-02
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Nicolas AUBIN
        email                : aubinnic@gmail.com
 ****************************************************************************/

/****************************************************************************
 *                                                                          *
 *   This program is free software: you can redistribute it and/or modify   *
 *   it under the terms of the GNU General Public License as published by   *
 *   the Free Software Foundation, either version 3 of the License, or      *
 *   (at your option) any later version.                                    *
 *                                                                          *
 *   This program is distributed in the hope that it will be useful,        *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
 *   GNU General Public License for more details.                           *
 *                                                                          *
 *   You should have received a copy of the GNU General Public License      *
 *   along with this program.  If not, see <https://www.gnu.org/licenses/>. *
 *                                                                          *
 ****************************************************************************/
"""

import os

from PyQt5.QtCore import QSettings
from qgis.PyQt import QtWidgets, uic, QtCore
from qgis.core import Qgis, QgsDataSourceUri, QgsProviderRegistry, QgsVectorLayer
from qgis.gui import QgsQueryBuilder
from .globals import log, init_catalog_data
from qgis.utils import spatialite_connect

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), '../ui/custom_catalog_set_database_connection.ui'))


class CustomCatalogAddConnexionDialog(QtWidgets.QDialog, FORM_CLASS):

    connectionDefined = QtCore.pyqtSignal(str)
    dialogClosed = QtCore.pyqtSignal()

    def __init__(self, parent=None, catalog_name=None, current_uri=None, edit_catalog=False, db_type=None):
        QtWidgets.QDialog.__init__(self, parent)
        self.setupUi(self)
        self.settings = QSettings()
        # Define supported database
        db_types = ["PostgreSQL", "SQLite", "Oracle"]
        # Add database types in combobox
        self.cbxDbType.addItems(db_types)
        # Init variables
        self.provider = None
        self.provider_key = None
        self.provider_grp = None
        self.catalog = catalog_name
        self.current_uri = current_uri
        self.edit_catalog = edit_catalog
        self.schema_separator = None
        self.default_catalog_table_name = "catalogs"
        if db_type:
            if db_type not in db_types:
                raise ValueError(self.tr("Database type is not valid. Accepted values : {}").format(str(db_types)))
            else:
                self.db_type = db_type
                self.lock_database_type(True)
        else:
            self.db_type = None
        # Default state geom widgets
        self.cbxGeom.setEnabled(False)
        self.txbxGeom.setEnabled(False)
        self.txbxFilterEx.setEnabled(False)
        self.txbxFilterCu.setEnabled(False)
        self.btnFilterEx.setEnabled(False)
        self.btnFilterCu.setEnabled(False)
        self.lblCbxGeom.setEnabled(False)
        self.lblTxbxGeom.setEnabled(False)
        self.lblFilterEx.setEnabled(False)
        self.lblFilterCu.setEnabled(False)
        # init values
        self.set_db_type()
        # call method when connexion type is modified
        self.cbxDbType.currentIndexChanged.connect(self.__on_cbxdbtype_changed)
        # Update groupbox state and call method when connexion name is modified
        self.rbExistingCnx.setChecked(True)
        self.__on_radiobtn_changed(True)
        self.rbExistingCnx.toggled.connect(self.__on_radiobtn_changed)
        # Init button OK
        self.btn_ok = self.buttonBox.button(QtWidgets.QDialogButtonBox.Ok)
        self.buttonBox.accepted.connect(self.__on_ok_clicked)
        self.buttonBox.rejected.connect(self.__on_cancel_clicked)
        # call method when connexion name is modified
        self.cbxCnx.currentIndexChanged.connect(self.__on_cbxcnx_changed)
        # call method when schema is modified
        self.cbxSchema.currentIndexChanged.connect(self.__on_cbxschema_changed)
        # call method when table is modified
        self.cbxTable.currentIndexChanged.connect(self.__on_cbxtable_changed)
        # call method when filter buttons clicked
        self.btnFilterEx.clicked.connect(self.__on_btnfilterex_clicked)
        self.btnFilterCu.clicked.connect(self.__on_btnfiltercu_clicked)
        # check if current_uri is set
        if self.current_uri:
            self.read_current_uri()
        # Check if edit_catalog mod
        if self.edit_catalog:
            self.cbxGeom.setEnabled(True)
            self.txbxGeom.setEnabled(True)
            self.txbxFilterEx.setEnabled(True)
            self.txbxFilterCu.setEnabled(True)
            self.btnFilterEx.setEnabled(True)
            self.btnFilterCu.setEnabled(True)
            self.lblCbxGeom.setEnabled(True)
            self.lblTxbxGeom.setEnabled(True)
            self.lblFilterEx.setEnabled(True)
            self.lblFilterCu.setEnabled(True)

    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        return QtCore.QCoreApplication.translate('CustomCatalogAddConnexionDialog', message)

    def read_current_uri(self):
        uri = QgsDataSourceUri(self.current_uri)
        self.rbNewCnx.setChecked(True)
        self.txbxService.setText(uri.service())
        self.txbxHost.setText(uri.host())
        self.txbxPort.setText(uri.port())
        self.txbxDb.setText(uri.database())
        self.txbxSchema.setText(uri.schema())
        self.txbxTable.setText(uri.table())
        self.txbxUser.setText(uri.username())
        self.txbxPass.setText(uri.password())
        self.txbxGeom.setText(uri.geometryColumn())
        self.txbxFilterCu.setText(uri.sql())

    def lock_database_type(self, lock):
        if lock:
            self.cbxDbType.setCurrentText(self.db_type)
            self.cbxDbType.setEnabled(False)

    def __on_btnfilterex_clicked(self):
        self.open_query_builder()

    def __on_btnfiltercu_clicked(self):
        self.open_query_builder()

    def __on_cbxdbtype_changed(self):
        self.set_db_type()

    def __on_cbxtable_changed(self):
        if self.edit_catalog:
            uri = self.set_uri()
            self.cbxGeom.clear()
            conn = self.provider.createConnection(uri.uri(), {})
            try:
                if self.rbExistingCnx.isChecked():
                    schema = self.cbxSchema.currentText()
                    table = self.cbxTable.currentText()
                else:
                    schema = self.txbxSchema.text()
                    table = self.txbxTable.text()
                fields = conn.fields(schema, table).names()
                geom_field = conn.table(schema, table).geometryColumn()
                self.cbxGeom.addItems(fields)
                if geom_field and geom_field not in fields:
                    self.cbxGeom.addItem(geom_field)
                if self.edit_catalog:
                    if geom_field:
                        self.cbxGeom.setCurrentText(geom_field)
                    elif "geom" in fields:
                        self.cbxGeom.setCurrentText("geom")

            except Exception as exc:
                log(str(exc), Qgis.Warning)

    def __on_cbxschema_changed(self):
        uri = self.set_uri()
        self.cbxTable.clear()
        conn = self.provider.createConnection(uri.uri(), {})
        try:
            tables = conn.tables(self.cbxSchema.currentText())
            tables_names = []
            for table in tables:
                tables_names.append(table.tableName())
            tables_names.sort(key=lambda v: v.upper())
            self.cbxTable.addItems(tables_names)

            if not self.edit_catalog:
                tables = [self.cbxTable.itemText(i) for i in range(self.cbxTable.count())]
                if self.default_catalog_table_name in tables:
                    self.cbxTable.setCurrentText(self.default_catalog_table_name)
                else:
                    self.cbxTable.insertItem(0, "NEW TABLE")
                    self.cbxTable.setCurrentIndex(0)

        except Exception as exc:
            log(str(exc), Qgis.Warning)

    def get_connections(self):
        if self.provider_grp != "" and self.provider_grp is not None:
            self.cbxCnx.clear()
            self.settings.beginGroup(self.provider_grp + "/connections")
            cnx = self.settings.childGroups()
            self.settings.endGroup()

            cnx.sort(key=lambda v: v.upper())
            self.cbxCnx.addItems(cnx)


    def set_provider(self):
        if self.db_type == "PostgreSQL":
            self.provider = QgsProviderRegistry.instance().providerMetadata('postgres')
            self.provider_grp = "PostgreSQL"
            self.schema_separator = "."
        elif self.db_type == "SQLite":
            self.provider = QgsProviderRegistry.instance().providerMetadata('spatialite')
            self.provider_grp = "SpatiaLite"
            self.schema_separator = ""
        elif self.db_type == "Oracle":
            self.provider = QgsProviderRegistry.instance().providerMetadata('oracle')
            self.provider_grp = "Oracle"
            self.schema_separator = "."
        self.provider_key = self.provider.key()

    def set_db_type(self):
        self.db_type = self.cbxDbType.currentText()
        self.set_provider()
        self.get_connections()

    def __on_radiobtn_changed(self, checked):
        if checked:
            self.gbxCustomCnx.setEnabled(True)
            self.gbxExistCnx.setEnabled(False)
        else:
            self.gbxCustomCnx.setEnabled(False)
            self.gbxExistCnx.setEnabled(True)

    def __on_cbxcnx_changed(self):
        self.set_provider()
        uri = self.set_uri()
        self.cbxSchema.clear()
        conn = self.provider.createConnection(uri.uri(), {})
        try:
            if self.provider_key == "spatialite":
                self.cbxSchema.addItem("")
            else:
                schemas = conn.schemas()
                schemas.sort(key=lambda v: v.upper())
                self.cbxSchema.addItems(schemas)
        except Exception:
            pass

    def open_query_builder(self):
        uri = self.set_layer_uri()
        if uri:
            layer = QgsVectorLayer(uri.uri(), "", self.provider_key)
            if layer.isValid():
                qb = QgsQueryBuilder(layer, self)

                if self.rbExistingCnx.isChecked():
                    txbx_filter = self.txbxFilterEx

                else:
                    txbx_filter = self.txbxFilterCu

                if qb.exec():
                    txbx_filter.setText(qb.sql())

    def set_uri(self):
        uri = QgsDataSourceUri()
        if self.rbExistingCnx.isChecked():
            cnx_info = self.provider_grp + "/connections/" + self.cbxCnx.currentText() + "/"
            if self.provider_key == "postgres" or self.provider_key == "oracle":
                service = self.settings.value(cnx_info + "service")
                auth_id = self.settings.value(cnx_info + "authcfg")
                if service:
                    uri.setConnection(service, None, None, None, authConfigId=auth_id)
                else:
                    host = self.settings.value(cnx_info + "host")
                    port = self.settings.value(cnx_info + "port")
                    database = self.settings.value(cnx_info + "database")
                    uri.setConnection(host, port, database, None, None)
                    if auth_id:
                        uri.setAuthConfigId(auth_id)
                    else:
                        uri.setUsername(self.settings.value(cnx_info + "username"))
                        uri.setPassword(self.settings.value(cnx_info + "password"))
                    #username = self.settings.value(cnx_info + "username")
                    #password = self.settings.value(cnx_info + "password")
                    #uri.setConnection(host, port, database, username, password)
            elif self.provider_key == "spatialite":
                sqlitepath = self.settings.value(cnx_info + "sqlitepath")
                uri.setDatabase(sqlitepath)
        else:
            service = self.txbxService.text()
            host = self.txbxHost.text()
            port = self.txbxPort.text()
            database = self.txbxDb.text()
            username = self.txbxUser.text()
            password = self.txbxPass.text()
            if service:
                uri.setConnection(service, database, username, password)
            else:
                uri.setConnection(host, port, database, username, password)
        return uri

    def set_layer_uri(self):
        uri = self.set_uri()
        try:
            if self.rbExistingCnx.isChecked():
                schema = self.cbxSchema.currentText()
                table = self.cbxTable.currentText()
                geom = self.cbxGeom.currentText()
                filter = self.txbxFilterEx.text()
            else:
                schema = self.txbxSchema.text()
                table = self.txbxTable.text()
                geom = self.txbxGeom.text()
                filter = self.txbxFilterCu.text()

            if self.edit_catalog:
                uri.setSchema(schema)
                uri.setTable(table)
                uri.setGeometryColumn(geom)
                uri.setSql(filter)
            else:
                default_catalog_data = init_catalog_data(self.catalog)
                conn = self.provider.createConnection(uri.uri(), {})
                sql_insert = "INSERT INTO {}{}{} (id, catalog_data) VALUES ('{}','{}');"
                sql_check_catalog = "SELECT count(id) as nb_catalogs FROM {}{}{} WHERE id='{}';"
                sql_create = "CREATE TABLE {}{}{}(id character varying(30) NOT NULL, catalog_data json, PRIMARY KEY (id));"
                uri.setDataSource(aSchema=schema, aTable=table, aGeometryColumn=None,
                                  aSql="id = '{}'".format(self.catalog))
                if table == "NEW TABLE" or table is None or table == "":
                    # Init messagebox
                    dialog = self.create_table_dialog()
                    # Create table and insert data if user press yes
                    create_table_response = dialog.exec()
                    if create_table_response == QtWidgets.QMessageBox.Yes:
                        table = self.default_catalog_table_name
                        conn.executeSql(sql_create.format(schema, self.schema_separator, table))
                        conn.executeSql(
                            sql_insert.format(schema, self.schema_separator, table, self.catalog, default_catalog_data))
                        uri.setTable(table)
                else:
                    tables = []
                    for t in conn.tables(schema):
                        tables.append(t.tableName())
                    # check if table exists in database
                    if table not in tables:
                        dialog = self.create_table_dialog()
                        create_table_response = dialog.exec()
                        if create_table_response == QtWidgets.QMessageBox.Yes:
                            conn.executeSql(sql_create.format(schema, self.schema_separator, table))
                            conn.executeSql(sql_insert.format(schema, self.schema_separator, table, self.catalog,
                                                              default_catalog_data))
                    # check if catalog exists in table
                    check = conn.executeSql(
                        sql_check_catalog.format(schema, self.schema_separator, table, self.catalog))
                    if check == [[0]]:
                        # Init messagebox
                        insert_catalog_dialog = QtWidgets.QMessageBox()
                        insert_catalog_dialog.setIcon(QtWidgets.QMessageBox.Warning)
                        insert_catalog_dialog.setText(self.tr("Catalog doesn't exist, do you want to create it ?"))
                        insert_catalog_dialog.setWindowTitle(self.tr("Create new entry in table"))
                        insert_catalog_dialog.setStandardButtons(QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
                        # Insert data if user press yes
                        create_table_response = insert_catalog_dialog.exec()
                        if create_table_response == QtWidgets.QMessageBox.Yes:
                            conn.executeSql(sql_insert.format(schema, self.schema_separator, table, self.catalog,
                                                              default_catalog_data))
            return uri

        except Exception as exc:
            return None
            log(str(exc), Qgis.Warning)

    def __on_ok_clicked(self):
        uri = self.set_layer_uri()
        if uri:
            uri.setAuthConfigId(None)
            self.connectionDefined.emit(uri.uri(expandAuthConfig=False))
            self.close()

    def create_table_dialog(self):
        dialog = QtWidgets.QMessageBox()
        dialog.setIcon(QtWidgets.QMessageBox.Warning)
        dialog.setText(self.tr("Table not defined or doesn't exist, do you want to create it ?"))
        dialog.setWindowTitle(self.tr("Create new table in database"))
        dialog.setStandardButtons(QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
        return dialog

    def __on_cancel_clicked(self):
        self.close()

    def closeEvent(self, event):
        self.dialogClosed.emit()
        event.accept()


