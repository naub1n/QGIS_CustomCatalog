# -*- coding: utf-8 -*-
"""
/****************************************************************************
 CustomCatalogDockWidget
                                 A QGIS plugin
 Create your own catalog based on various sources and versions
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-11-02
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Nicolas AUBIN
        email                : aubinnic@gmail.com
 ****************************************************************************/

/****************************************************************************
 *                                                                          *
 *   This program is free software: you can redistribute it and/or modify   *
 *   it under the terms of the GNU General Public License as published by   *
 *   the Free Software Foundation, either version 3 of the License, or      *
 *   (at your option) any later version.                                    *
 *                                                                          *
 *   This program is distributed in the hope that it will be useful,        *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
 *   GNU General Public License for more details.                           *
 *                                                                          *
 *   You should have received a copy of the GNU General Public License      *
 *   along with this program.  If not, see <https://www.gnu.org/licenses/>. *
 *                                                                          *
 ****************************************************************************/
"""

import os

from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, QCoreApplication
from qgis.core import Qgis
from .globals import log, load_settings, read_catalogs, CustomCatalogTreeWidgetItem, \
    get_icon, check_keys, load_layer


FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), '../ui/custom_catalog_dockwidget_base.ui'))


class CustomCatalogDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(CustomCatalogDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        # Define columns ID
        self.name_col_id = 0
        self.version_col_id = 1
        self.format_col_id = 2
        self.link_col_id = 3
        # Define Tree Widget
        self.tree = self.treeWidget
        # Init settings variable
        self.settings = None
        self.setting_name = None
        # Init catalog name variable
        self.catalog_name = None
        # Build tree content
        self.build_tree()

    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        return QCoreApplication.translate('CustomCatalogDockWidget', message)

    def __on_item_doubleclicked(self, item):
        if item.catalog_type == "layer":
            # Add layer to map
            self.add_layer_to_map(item)

    def add_layer_to_map(self, item):
        layer_version = self.tree.itemWidget(item, self.version_col_id).currentText()
        layer_format = self.tree.itemWidget(item, self.format_col_id).currentText()
        layer_link = item.text(self.link_col_id)
        layer_name = item.text(self.name_col_id)
        layer_title = layer_name + "_" + layer_version

        load_layer(layer_title, layer_format, layer_link)

    def read_levels(self, children_dict, parent=None):
        for item in children_dict:
            if check_keys(item, self.setting_name):
                if item['type'] == "catalog":
                    self.catalog_name = item['name']
                    catalog_root_item = CustomCatalogTreeWidgetItem(None, item['type'])
                    catalog_root_item.setText(self.name_col_id, item['name'])
                    catalog_root_item.setIcon(self.name_col_id, get_icon("catalog"))
                    self.tree.addTopLevelItem(catalog_root_item)
                    self.read_levels(item['children'], catalog_root_item)
                else:
                    widget_item = CustomCatalogTreeWidgetItem(parent, item['type'])
                    widget_item.setText(self.name_col_id, item['name'])

                    if widget_item.catalog_type == "node":
                        widget_item.setIcon(0, get_icon(item['type']))
                        if 'children' in item and len(item['children']) != 0:
                            self.read_levels(item['children'], widget_item)

                    elif widget_item.catalog_type == "layer":
                        widget_item.setIcon(self.name_col_id, get_icon(item['geomtype']))
                        # Init combobox version
                        cbx_version = self.__build_cbx_versions(item['versions'], widget_item)
                        self.tree.setItemWidget(widget_item, self.version_col_id, cbx_version)
                        # Init combobox format
                        cbx_format = self.__build_cbx_formats(item['versions'], widget_item)
                        self.tree.setItemWidget(widget_item, self.format_col_id, cbx_format)


    def __build_cbx_formats(self, versions, item):
        current_version = self.tree.itemWidget(item, self.version_col_id).currentText()
        for v in versions:
            if v['version'] == current_version:
                formats = v['formats']

        cbx_format = QtWidgets.QComboBox()
        cbx_format.currentTextChanged.connect(lambda layer_format: self.__build_link(versions, item, layer_format))
        for f in formats:
            cbx_format.addItem(f['format'])

        return cbx_format

    def __on_cbx_versions_changed(self, versions, item):
        current_version = self.tree.itemWidget(item, self.version_col_id).currentText()
        cbx_format = self.tree.itemWidget(item, self.format_col_id)
        cbx_format.clear()
        for v in versions:
            if v['version'] == current_version:
                formats = v['formats']
                for f in formats:
                    cbx_format.addItem(f['format'])
        self.__build_link(versions, item)

    def __build_cbx_versions(self, versions, item):
        cbx_versions = QtWidgets.QComboBox()
        for v in versions:
            cbx_versions.addItem(v['version'])
        cbx_versions.setCurrentIndex(0)
        cbx_versions.currentTextChanged.connect(lambda: self.__on_cbx_versions_changed(versions, item))
        return cbx_versions

    def __build_link(self, versions, item, format=None):
        current_version = self.tree.itemWidget(item, self.version_col_id).currentText()
        if format is None:
            format = self.tree.itemWidget(item, self.format_col_id).currentText()
        for v in versions:
            if v['version'] == current_version:
                for f in v['formats']:
                    if f['format'] == format:
                        link = f['link']
                        if format == "PostGIS" and 'qgisauthconfigid' in f:
                            if f['qgisauthconfigid'] != "":
                                link = link + " sslmode=disable authcfg=" + f['qgisauthconfigid']
                        item.setText(self.link_col_id, link)
                        layer_version = self.tree.itemWidget(item, self.version_col_id).currentText()
                        item.layer_title = item.text(self.name_col_id) + "_" + layer_version

    def resize_columns(self):
        col_count = self.tree.columnCount()
        for i in range(col_count - 1):
            self.tree.resizeColumnToContents(i)

    def build_tree(self):
        # If treeWidget already exists, it is cleared
        self.tree.clear()
        # If treeWidget already exists, it should be disconnected.
        # But if doesn't already connected, disconnecting it cause an error
        try:
            self.tree.itemDoubleClicked.disconnect()
        except Exception:
            pass
        self.settings = load_settings()
        for setting in self.settings['catalogs']:
            self.setting_name = setting['name']
            # read catalogs
            catalogs = read_catalogs(setting['type'], setting['link'], setting['qgisauthconfigid'])
            if catalogs is None:
                log(self.tr("Unable to read setting") + " " + self.setting_name, Qgis.Critical)
            else:
                # Build catalog
                self.read_levels(catalogs)
        self.tree.expandAll()
        self.tree.hideColumn(self.link_col_id)
        self.tree.itemDoubleClicked.connect(self.__on_item_doubleclicked)
        self.resize_columns()

    def closeEvent(self, event):
        self.tree.itemDoubleClicked.disconnect()
        self.closingPlugin.emit()
        event.accept()
