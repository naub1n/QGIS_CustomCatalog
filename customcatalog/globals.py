# -*- coding: utf-8 -*-
"""
/****************************************************************************
 CustomCatalog
                                 A QGIS plugin
 Create your own catalog based on various sources and versions
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-11-02
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Nicolas AUBIN
        email                : aubinnic@gmail.com
 ****************************************************************************/

/****************************************************************************
 *                                                                          *
 *   This program is free software: you can redistribute it and/or modify   *
 *   it under the terms of the GNU General Public License as published by   *
 *   the Free Software Foundation, either version 3 of the License, or      *
 *   (at your option) any later version.                                    *
 *                                                                          *
 *   This program is distributed in the hope that it will be useful,        *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
 *   GNU General Public License for more details.                           *
 *                                                                          *
 *   You should have received a copy of the GNU General Public License      *
 *   along with this program.  If not, see <https://www.gnu.org/licenses/>. *
 *                                                                          *
 ****************************************************************************/
"""

import json
import os

from qgis.PyQt import QtCore, QtWidgets, QtGui
from qgis.core import QgsMessageLog, QgsApplication, Qgis, QgsRasterLayer, QgsVectorLayer, QgsProviderRegistry, \
    QgsDataSourceUri, QgsProject, QgsLayerDefinition
from qgis.utils import iface

settings_file = os.path.join(os.path.dirname(__file__), '../conf/settings.json')


def catalog_type_values():
    values = [
        'json',
        'PostgreSQL'
    ]
    return values


def catalog_item_type_values():
    values = [
        'node',
        'layer',
        'catalog'
    ]
    values.sort()
    return values


def layer_format_values():
    values = [
        'WMS',
        'WMTS',
        'WFS',
        'OGR',
        'GPKG',
        'SHP',
        'PostGIS',
        'QLR'
    ]
    values.sort()
    return values

def layer_geom_values():
    values = [
        'polygon',
        'line',
        'point',
        'raster'
    ]
    values.sort()
    return values

def init_catalog_data(catalog_name, indent=None):
    data = [{"name": catalog_name, "type": "catalog", "children": []}]
    json_data = json.dumps(data, indent=indent)
    return json_data

def load_settings():
    with open(settings_file) as f:
        settings = json.load(f)
    return settings


def tr(message):
    return QtCore.QCoreApplication.translate('@default', message)


def log(log_message, level_message, detail_message=None):
    iface.messageBar().pushMessage(log_message, level=level_message, duration=3)
    if detail_message is None:
        notify_user = False
    else:
        notify_user = True
    QgsMessageLog.logMessage(log_message, 'Custom catalog', level=level_message, notifyUser=notify_user)
    if detail_message is not None:
        QgsMessageLog.logMessage(tr("Details") + " : " + detail_message, 'Custom catalog', level=level_message)


def build_cbx_type(cbx_widget):
    if isinstance(cbx_widget, QtWidgets.QComboBox):
        values = catalog_type_values()
        cbx_widget.addItems(values)


def build_cbx_authid(cbx_widget, selected_value=None):
    if isinstance(cbx_widget, QtWidgets.QComboBox):
        values = ['']
        values.extend(QgsApplication.authManager().configIds())
        cbx_widget.addItems(values)
        if selected_value is not None and selected_value in values:
            cbx_widget.setCurrentText(selected_value)


def read_catalogs(file_format, path, authid=None):
    if file_format == "json":
        if path is None or path == "":
            filePath = os.path.dirname(__file__)
            path = os.path.join(filePath, '../catalog/default_catalog.json')
        # read catalogs
        elif not os.path.isfile(path):
            log(tr("Catalog path error"), Qgis.Critical, path + " " + tr("does not exists"))
            return

        with open(path) as f:
            catalogs = json.load(f)
        return catalogs
    elif file_format == "PostgreSQL":
        try:
            provider = QgsProviderRegistry.instance().providerMetadata('postgres')
            uri = QgsDataSourceUri(path)
            uri.setAuthConfigId(authid)
            conn = provider.createConnection(uri.uri(), {})
            schema = uri.schema()
            table = uri.table()
            sql = uri.sql()
            data = conn.executeSql('SELECT catalog_data FROM "' + schema + '"."' + table + '" WHERE ' + sql)[0][0]
            catalogs = json.loads(data)
            return catalogs
        except Exception as exc:
            log(str(exc), Qgis.Warning)


def get_icon(data_type):
    if data_type == "line":
        icon = QtGui.QIcon(QgsApplication.iconPath("mIconLineLayer.svg"))
    elif data_type == "polygon":
        icon = QtGui.QIcon(QgsApplication.iconPath("mIconPolygonLayer.svg"))
    elif data_type == "point":
        icon = QtGui.QIcon(QgsApplication.iconPath("mIconPointLayer.svg"))
    elif data_type == "node":
        icon = QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.SP_DirIcon)
    elif data_type == "catalog":
        icon = QtGui.QIcon(':/plugins/custom_catalog/icon.png')
    else:
        icon = QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.SP_FileIcon)
    return icon


def cbx_defaults_authid(selected_value=None):
    cbx_auth = QtWidgets.QComboBox()
    values = ['']
    values.extend(QgsApplication.authManager().configIds())
    cbx_auth.addItems(values)
    if selected_value is not None and selected_value in values:
        cbx_auth.setCurrentText(selected_value)
    return cbx_auth

def check_keys(item_catalog, setting_name):
    keys = ["name", "type"]
    if set(keys).issubset(item_catalog):
        item_type = item_catalog["type"]
        if item_type is None:
            keys.append("children")
        elif item_type in ["catalog", "node"]:
            keys.append("children")
        elif item_type == "layer":
            keys.append("geomtype")
            keys.append("versions")
        if set(keys).issubset(item_catalog):
            return True

    error_keys = []
    for key in keys:
        if key not in item_catalog:
            error_keys.append(key)
    if 'name' in error_keys:
        item_name = None
    else:
        item_name = item_catalog['name']
    log(tr("Keys are missing in setting") + " " + setting_name, Qgis.Warning,
        tr("Item name") + " : " + str(item_name) + " ; " + tr("Keys") + " : " + str(error_keys))
    return False

def load_layer(layer_title, layer_format, layer_link, layer_auth=None, check_only=False):
    layer = None

    if layer_auth is not None and layer_auth != "":
        layer_link = layer_link + " sslmode=disable authcfg=" + layer_auth

    if layer_format == "WMS" or layer_format == "WMTS":
        layer = QgsRasterLayer(layer_link, layer_title, "wms")
    elif layer_format == "WFS":
        layer = QgsVectorLayer(layer_link, layer_title, "wfs")
    elif layer_format == "OGR" or layer_format == "GPKG" or layer_format == "SHP":
        layer = QgsVectorLayer(layer_link, layer_title, "ogr")
    elif layer_format == "PostGIS":
        layer = QgsVectorLayer(layer_link, layer_title, "postgres")
    elif layer_format == "QLR":
        inst = QgsProject.instance()
        if check_only:
            group_name = "group_check"
            root = QgsProject.instance().layerTreeRoot()
            group = root.addGroup(group_name)
        else:
            group = inst.layerTreeRoot()
        load_result = QgsLayerDefinition().loadLayerDefinition(layer_link, inst, group)
        if check_only:
            root.removeChildNode(group)

    if check_only:
        check_result = False
        if isinstance(layer, QgsVectorLayer) or isinstance(layer, QgsRasterLayer):
            check_result = layer.isValid()
        elif layer_format == "QLR":
            check_result = load_result[0]

        return check_result
    else:
        msg_ok = tr("Layer loaded") + " : " + layer_title
        msg_error = tr("Invalid layer") + " : " + layer_title
        if isinstance(layer, QgsVectorLayer) or isinstance(layer, QgsRasterLayer):
            if layer.isValid():
                QgsProject.instance().addMapLayer(layer)
                log(msg_ok, Qgis.Info)
            else:
                log(msg_error, Qgis.Warning, layer_link)
        elif layer_format == "QLR":
            if load_result[0]:
                log(msg_ok, Qgis.Info)
            else:
                log(msg_error, Qgis.Warning, layer_link)




class BuildCatalog:
    def __init__(self, read_levels_method, tree_widget, catalog, catalog_name, name_col_id, link_col_id, version_col_id, format_col_id,
                  node_type_col_id=None, geom_col_id=None, auth_col_id=None, edit=False):

        self.tree = tree_widget

        keys = ["name", "type", "catalog"]

        if set(keys).issubset(catalog):
            if catalog['type'] == "catalog":
                # catalog_root_item = QtWidgets.QTreeWidgetItem([catalog['name']])
                catalog_root_item = CustomCatalogTreeWidgetItem(None, catalog['type'])
                catalog_root_item.setText(name_col_id, catalog['name'])
                catalog_root_item.setIcon(name_col_id, get_icon("catalog"))
                self.tree.addTopLevelItem(catalog_root_item)
                if edit:
                    self.tree.setItemWidget(catalog_root_item, node_type_col_id,
                                            self.cbx_defaults_types_nodes(catalog['type'], enabled=False))
                read_levels_method(catalog['catalog'], catalog_root_item, self.tree, catalog['name'], name_col_id,
                            link_col_id, version_col_id, format_col_id, node_type_col_id=node_type_col_id,
                            geom_col_id=geom_col_id, auth_col_id=auth_col_id, edit=edit)
            else:
                log(catalog_name + " " + tr("is not a catalog type"), Qgis.Warning)
                return
        else:
            error_keys = []
            for key in keys:
                if key not in catalog:
                    error_keys.append(key)
            log("Keys are missing in catalog" + " " + catalog_name, Qgis.Warning, str(error_keys))
            return

    def cbx_defaults_types_nodes(self, selected_value=None, enabled=True):
        cbx_type = QtWidgets.QComboBox()
        defaults_values = catalog_item_type_values()
        for value in defaults_values:
            cbx_type.addItem(value)
        if selected_value is not None and selected_value in defaults_values:
            cbx_type.setCurrentText(selected_value)
        cbx_type.setEnabled(enabled)
        return cbx_type


class CustomCatalogTreeWidgetItem(QtWidgets.QTreeWidgetItem):
    def __init__(self, parent=None, catalog_type="", editable_cols=[], editable=False):
        super().__init__(parent)
        self.catalog_type = catalog_type
        self.editable_cols = editable_cols
        self.parent = parent
        self.tree = self.treeWidget()

        self.itemName = None
        self.itemType = None
        self.itemGeom = None
        self.itemVersion = None
        self.itemFormat = None
        self.itemLink = None
        self.itemAuth = None
        # Init data variable
        self.data = None
        if editable:
            self.setEditable(editable)

    def setEditable(self, editable):
        if editable:
            self.setFlags(self.flags() | QtCore.Qt.ItemIsEditable)
        else:
            self.setFlags(self.flags() ^ QtCore.Qt.ItemIsEditable)

    def readData(self):
        if self.catalog_type == 'format':
            data = {'format': self.itemFormat,
                    'link': self.itemLink,
                    'qgisauthconfigid': self.itemAuth}
            self.data = data
            return data
        elif self.catalog_type == 'version':
            data_formats = []
            for index_child in range(self.childCount()):
                data_formats.append(self.child(index_child).readData())
            data = {'version': self.itemVersion,
                    'formats': data_formats}
            self.data = data
            return data
        elif self.catalog_type == 'layer':
            data_versions = []
            for index_child in range(self.childCount()):
                data_versions.append(self.child(index_child).readData())
            data = {'name': self.itemName,
                    'type': "layer",
                    'geomtype': self.itemGeom,
                    'versions': data_versions}
            self.data = data
            return data
        elif self.catalog_type in ['node', 'catalog']:
            data_nodes = []
            for index_child in range(self.childCount()):
                data_nodes.append(self.child(index_child).readData())
            data = {'name': self.itemName,
                    'type': self.itemType,
                    'children': data_nodes}
            self.data = data
            return data

